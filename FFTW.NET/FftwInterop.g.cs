#region Copyright and License

/*
This file is part of FFTW.NET, a wrapper around the FFTW library
for the .NET framework.
Copyright (C) 2017 Tobias Meyer

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#endregion

// AUTOGENERATED FILE
// DO NOT MODIFY
using System;
using System.Runtime.InteropServices;

namespace FFTW.NET
{
	/// <summary>
	///     Provides access to FFTW C functions.
	///     For a documentation of this functions see
	///     http://www.fftw.org/fftw3_doc/index.html
	/// </summary>
	public static partial class FftwInterop
    {
        #region fftw_init_threads

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_init_threads")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool fftw_init_threads_x86();

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_init_threads")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool fftw_init_threads_x64();

        public static bool fftw_init_threads()
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                return fftw_init_threads_x64();
            }

            if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                return fftw_init_threads_x86();
            }

            throw new PlatformNotSupportedException();
        }

        #endregion

        #region fftw_plan_with_nthreads

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl,
            EntryPoint = "fftw_plan_with_nthreads")]
        private static extern void fftw_plan_with_nthreads_x86(
            int nthreads);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl,
            EntryPoint = "fftw_plan_with_nthreads")]
        private static extern void fftw_plan_with_nthreads_x64(
            int nthreads);

        public static void fftw_plan_with_nthreads(
            int nthreads)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                fftw_plan_with_nthreads_x64(nthreads);
            }
            else if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                fftw_plan_with_nthreads_x86(nthreads);
            }
            else
            {
                throw new PlatformNotSupportedException();
            }
        }

        #endregion

        #region fftw_plan_dft

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_plan_dft")]
        private static extern IntPtr fftw_plan_dft_x86(
            int rank,
            [MarshalAs(UnmanagedType.LPArray)] int[] n,
            IntPtr arrIn,
            IntPtr arrOut,
            DftDirection direction,
            PlannerFlags flags);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_plan_dft")]
        private static extern IntPtr fftw_plan_dft_x64(
            int rank,
            [MarshalAs(UnmanagedType.LPArray)] int[] n,
            IntPtr arrIn,
            IntPtr arrOut,
            DftDirection direction,
            PlannerFlags flags);

        public static IntPtr fftw_plan_dft(
            int rank,
            [MarshalAs(UnmanagedType.LPArray)] int[] n,
            IntPtr arrIn,
            IntPtr arrOut,
            DftDirection direction,
            PlannerFlags flags)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                return fftw_plan_dft_x64(rank, n, arrIn, arrOut, direction, flags);
            }

            if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                return fftw_plan_dft_x86(rank, n, arrIn, arrOut, direction, flags);
            }

            throw new PlatformNotSupportedException();
        }

        #endregion

        #region fftw_plan_dft_r2c

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_plan_dft_r2c")]
        private static extern IntPtr fftw_plan_dft_r2c_x86(
            int rank,
            [MarshalAs(UnmanagedType.LPArray)] int[] n,
            IntPtr arrIn,
            IntPtr arrOut,
            PlannerFlags flags);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_plan_dft_r2c")]
        private static extern IntPtr fftw_plan_dft_r2c_x64(
            int rank,
            [MarshalAs(UnmanagedType.LPArray)] int[] n,
            IntPtr arrIn,
            IntPtr arrOut,
            PlannerFlags flags);

        public static IntPtr fftw_plan_dft_r2c(
            int rank,
            [MarshalAs(UnmanagedType.LPArray)] int[] n,
            IntPtr arrIn,
            IntPtr arrOut,
            PlannerFlags flags)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                return fftw_plan_dft_r2c_x64(rank, n, arrIn, arrOut, flags);
            }

            if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                return fftw_plan_dft_r2c_x86(rank, n, arrIn, arrOut, flags);
            }

            throw new PlatformNotSupportedException();
        }

        #endregion

        #region fftw_plan_dft_c2r

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_plan_dft_c2r")]
        private static extern IntPtr fftw_plan_dft_c2r_x86(
            int rank,
            [MarshalAs(UnmanagedType.LPArray)] int[] n,
            IntPtr arrIn,
            IntPtr arrOut,
            PlannerFlags flags);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_plan_dft_c2r")]
        private static extern IntPtr fftw_plan_dft_c2r_x64(
            int rank,
            [MarshalAs(UnmanagedType.LPArray)] int[] n,
            IntPtr arrIn,
            IntPtr arrOut,
            PlannerFlags flags);

        public static IntPtr fftw_plan_dft_c2r(
            int rank,
            [MarshalAs(UnmanagedType.LPArray)] int[] n,
            IntPtr arrIn,
            IntPtr arrOut,
            PlannerFlags flags)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                return fftw_plan_dft_c2r_x64(rank, n, arrIn, arrOut, flags);
            }

            if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                return fftw_plan_dft_c2r_x86(rank, n, arrIn, arrOut, flags);
            }

            throw new PlatformNotSupportedException();
        }

        #endregion

        #region fftw_destroy_plan

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_destroy_plan")]
        private static extern void fftw_destroy_plan_x86(
            IntPtr plan);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_destroy_plan")]
        private static extern void fftw_destroy_plan_x64(
            IntPtr plan);

        public static void fftw_destroy_plan(
            IntPtr plan)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                fftw_destroy_plan_x64(plan);
            }
            else if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                fftw_destroy_plan_x86(plan);
            }
            else
            {
                throw new PlatformNotSupportedException();
            }
        }

        #endregion

        #region fftw_execute

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_execute")]
        private static extern void fftw_execute_x86(
            IntPtr plan);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_execute")]
        private static extern void fftw_execute_x64(
            IntPtr plan);

        public static void fftw_execute(
            IntPtr plan)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                fftw_execute_x64(plan);
            }
            else if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                fftw_execute_x86(plan);
            }
            else
            {
                throw new PlatformNotSupportedException();
            }
        }

        #endregion

        #region fftw_export_wisdom_to_filename

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl,
            EntryPoint = "fftw_export_wisdom_to_filename")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool fftw_export_wisdom_to_filename_x86(
            [MarshalAs(UnmanagedType.LPStr)] string filename);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl,
            EntryPoint = "fftw_export_wisdom_to_filename")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool fftw_export_wisdom_to_filename_x64(
            [MarshalAs(UnmanagedType.LPStr)] string filename);

        public static bool fftw_export_wisdom_to_filename(
            [MarshalAs(UnmanagedType.LPStr)] string filename)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                return fftw_export_wisdom_to_filename_x64(filename);
            }

            if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                return fftw_export_wisdom_to_filename_x86(filename);
            }

            throw new PlatformNotSupportedException();
        }

        #endregion

        #region fftw_import_wisdom_from_filename

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl,
            EntryPoint = "fftw_import_wisdom_from_filename")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool fftw_import_wisdom_from_filename_x86(
            [MarshalAs(UnmanagedType.LPStr)] string filename);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl,
            EntryPoint = "fftw_import_wisdom_from_filename")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool fftw_import_wisdom_from_filename_x64(
            [MarshalAs(UnmanagedType.LPStr)] string filename);

        public static bool fftw_import_wisdom_from_filename(
            [MarshalAs(UnmanagedType.LPStr)] string filename)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                return fftw_import_wisdom_from_filename_x64(filename);
            }

            if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                return fftw_import_wisdom_from_filename_x86(filename);
            }

            throw new PlatformNotSupportedException();
        }

        #endregion

        #region fftw_import_wisdom_from_string

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl,
            EntryPoint = "fftw_import_wisdom_from_string")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool fftw_import_wisdom_from_string_x86(
            [MarshalAs(UnmanagedType.LPStr)] string wisdom);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl,
            EntryPoint = "fftw_import_wisdom_from_string")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool fftw_import_wisdom_from_string_x64(
            [MarshalAs(UnmanagedType.LPStr)] string wisdom);

        public static bool fftw_import_wisdom_from_string(
            [MarshalAs(UnmanagedType.LPStr)] string wisdom)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                return fftw_import_wisdom_from_string_x64(wisdom);
            }

            if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                return fftw_import_wisdom_from_string_x86(wisdom);
            }

            throw new PlatformNotSupportedException();
        }

        #endregion

        #region fftw_export_wisdom

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_export_wisdom")]
        private static extern void fftw_export_wisdom_x86(
            [MarshalAs(UnmanagedType.FunctionPtr)] WriteCharHandler writeChar,
            IntPtr data);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_export_wisdom")]
        private static extern void fftw_export_wisdom_x64(
            [MarshalAs(UnmanagedType.FunctionPtr)] WriteCharHandler writeChar,
            IntPtr data);

        public static void fftw_export_wisdom(
            [MarshalAs(UnmanagedType.FunctionPtr)] WriteCharHandler writeChar,
            IntPtr data)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                fftw_export_wisdom_x64(writeChar, data);
            }
            else if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                fftw_export_wisdom_x86(writeChar, data);
            }
            else
            {
                throw new PlatformNotSupportedException();
            }
        }

        #endregion

        #region fftw_forget_wisdom

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_forget_wisdom")]
        private static extern void fftw_forget_wisdom_x86();

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_forget_wisdom")]
        private static extern void fftw_forget_wisdom_x64();

        public static void fftw_forget_wisdom()
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                fftw_forget_wisdom_x64();
            }
            else if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                fftw_forget_wisdom_x86();
            }
            else
            {
                throw new PlatformNotSupportedException();
            }
        }

        #endregion

        #region fftw_malloc

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_malloc")]
        private static extern IntPtr fftw_malloc_x86(
            IntPtr size);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_malloc")]
        private static extern IntPtr fftw_malloc_x64(
            IntPtr size);

        public static IntPtr fftw_malloc(
            IntPtr size)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                return fftw_malloc_x64(size);
            }

            if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                return fftw_malloc_x86(size);
            }

            throw new PlatformNotSupportedException();
        }

        #endregion

        #region fftw_free

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_free")]
        private static extern void fftw_free_x86(
            IntPtr ptr);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_free")]
        private static extern void fftw_free_x64(
            IntPtr ptr);

        public static void fftw_free(
            IntPtr ptr)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                fftw_free_x64(ptr);
            }
            else if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                fftw_free_x86(ptr);
            }
            else
            {
                throw new PlatformNotSupportedException();
            }
        }

        #endregion

        #region fftw_alignment_of

        [DllImport("libfftw3-3-x86", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_alignment_of")]
        private static extern int fftw_alignment_of_x86(
            IntPtr ptr);

        [DllImport("libfftw3-3-x64", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fftw_alignment_of")]
        private static extern int fftw_alignment_of_x64(
            IntPtr ptr);

        public static int fftw_alignment_of(
            IntPtr ptr)
        {
            if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
            {
                return fftw_alignment_of_x64(ptr);
            }

            if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
            {
                return fftw_alignment_of_x86(ptr);
            }

            throw new PlatformNotSupportedException();
        }

        #endregion
    }
}